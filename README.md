🌦️ Dynamic Weather App

How to setup the project 
Ensure you have the following installed:
Git: To clone the repository
Node.js: Ensure you have Node.js installed
PNPM: Package manager (install via npm install -g pnpm if not already installed)

1.Clone the Repository: git clone https://github.com/kanwarsinghrajawat/dynamic-weather-app
2.Navigate to the Project Directory: cd dynamic-weather-app.
3. Install Dependencies:pnpm i.
4.Set Up Environment Variables:Generate an API Key from OpenWeather, Create a .env file in the project root.
5.Run the Development Server: pnpm dev.

Project is Running Successfully!



🛠️ Technologies Used
✅ Frontend Framework: React.js – Component-based UI development.
✅ Styling: Tailwind CSS – Utility-first CSS framework for modern UI.
✅ Icons: React Icons – Lightweight and customizable.
✅ API Calls: Axios – Fetches weather data efficiently.
✅ State Management: Redux Toolkit – Efficient global state handling.
✅ Images: Unsplash – High-quality images for UI enhancements.
✅ Environment Variables: .env – Secure API key storage.
✅ Deployment: Vercel – CI/CD cloud hosting for seamless updates.



🌟 Features
✔ City Suggestions API – Fetch real-time suggestions via OpenWeather API.
✔ Weather Data API – Display live weather updates for selected cities.
✔ Dark & Light Mode – Seamless theme switching.
✔ Local Storage – Persist user-selected cities for quick access.
✔ Search Functionality – Dynamic city search.
✔ Debouncing – Optimized API calls for efficiency.
✔ Multi-City Display – View weather data in grid/list format.
✔ City Removal – Easily remove cities from the dashboard.
✔ Modals – Interactive search pop-ups.
✔ Responsive Design – Optimized for mobile, tablet, and desktop.
✔ Error Handling – Friendly messages for API failures.


 Future Improvements
🔹 Migration to Next.js – Enhance performance, SEO, and enable server-side rendering.
🔹 Optimized API Calls – Prevent unnecessary requests when the search input has fewer than two characters and so on.
🔹 TypeScript Configuration – Enforce type safety and improve maintainability.
🔹 Better Code Organization – Store constants and content in separate files for reusability.
🔹 Code Quality & Standards – Implement Husky and ESLint for automated pre-commit checks.
🔹 Tailwind CSS Enhancements – Define color variables for consistency.
🔹 Optimized Assets – Convert JPG images to SVG for better performance.
🔹 Multi-Language Support – Make the app accessible globally.
🔹 Improved Loading State – Use skeleton loaders or animated placeholders.

